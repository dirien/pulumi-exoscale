// *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

import * as pulumi from "@pulumi/pulumi";
import * as inputs from "../types/input";
import * as outputs from "../types/output";

export interface ComputeInstanceNetworkInterface {
    ipAddress?: string;
    networkId: string;
}

export interface DatabaseKafka {
    enableCertAuth: boolean;
    enableKafkaConnect?: boolean;
    enableKafkaRest?: boolean;
    enableSaslAuth: boolean;
    enableSchemaRegistry?: boolean;
    ipFilters: string[];
    kafkaConnectSettings: string;
    kafkaRestSettings: string;
    kafkaSettings: string;
    schemaRegistrySettings: string;
    version: string;
}

export interface DatabaseMysql {
    adminPassword: string;
    adminUsername: string;
    backupSchedule: string;
    ipFilters: string[];
    mysqlSettings: string;
    version: string;
}

export interface DatabaseOpensearch {
    dashboards?: outputs.DatabaseOpensearchDashboards;
    forkFromService?: string;
    indexPatterns?: outputs.DatabaseOpensearchIndexPattern[];
    indexTemplate?: outputs.DatabaseOpensearchIndexTemplate;
    ipFilters: string[];
    keepIndexRefreshInterval?: boolean;
    maxIndexCount?: number;
    recoveryBackupName?: string;
    settings?: string;
    version: string;
}

export interface DatabaseOpensearchDashboards {
    enabled?: boolean;
    maxOldSpaceSize?: number;
    requestTimeout?: number;
}

export interface DatabaseOpensearchIndexPattern {
    maxIndexCount?: number;
    pattern?: string;
    sortingAlgorithm?: string;
}

export interface DatabaseOpensearchIndexTemplate {
    mappingNestedObjectsLimit?: number;
    numberOfReplicas?: number;
    numberOfShards?: number;
}

export interface DatabasePg {
    adminPassword: string;
    adminUsername: string;
    backupSchedule: string;
    ipFilters: string[];
    pgSettings: string;
    pgbouncerSettings: string;
    pglookoutSettings: string;
    version: string;
}

export interface DatabaseRedis {
    ipFilters: string[];
    redisSettings: string;
}

export interface ElasticIPHealthcheck {
    interval?: number;
    mode: string;
    port: number;
    strikesFail?: number;
    strikesOk?: number;
    timeout?: number;
    tlsSkipVerify?: boolean;
    tlsSni?: string;
    uri?: string;
}

export interface GetComputeInstanceListInstance {
    antiAffinityGroupIds?: string[];
    /**
     * Match against this string. If you supply a string that begins and ends with a "/" it will be matched as a regex.
     */
    createdAt: string;
    /**
     * Match against this string. If you supply a string that begins and ends with a "/" it will be matched as a regex.
     */
    deployTargetId: string;
    /**
     * Match against this int
     */
    diskSize: number;
    elasticIpIds: string[];
    /**
     * Match against this string. If you supply a string that begins and ends with a "/" it will be matched as a regex.
     */
    id?: string;
    /**
     * Match against this bool
     */
    ipv6: boolean;
    /**
     * Match against this string. If you supply a string that begins and ends with a "/" it will be matched as a regex.
     */
    ipv6Address: string;
    /**
     * Match against key/values. Keys are matched exactly, while values may be matched as a regex if you supply a string that begins and ends with "/"
     */
    labels?: {[key: string]: string};
    /**
     * Match against this string. If you supply a string that begins and ends with a "/" it will be matched as a regex.
     */
    managerId: string;
    /**
     * Match against this string. If you supply a string that begins and ends with a "/" it will be matched as a regex.
     */
    managerType: string;
    /**
     * Match against this string. If you supply a string that begins and ends with a "/" it will be matched as a regex.
     */
    name?: string;
    privateNetworkIds: string[];
    /**
     * Match against this string. If you supply a string that begins and ends with a "/" it will be matched as a regex.
     */
    publicIpAddress: string;
    /**
     * Match against this string. If you supply a string that begins and ends with a "/" it will be matched as a regex.
     */
    reverseDns: string;
    securityGroupIds: string[];
    /**
     * Match against this string. If you supply a string that begins and ends with a "/" it will be matched as a regex.
     */
    sshKey: string;
    /**
     * Match against this string. If you supply a string that begins and ends with a "/" it will be matched as a regex.
     */
    state: string;
    /**
     * Match against this string. If you supply a string that begins and ends with a "/" it will be matched as a regex.
     */
    templateId: string;
    /**
     * Match against this string. If you supply a string that begins and ends with a "/" it will be matched as a regex.
     */
    type: string;
    /**
     * Match against this string. If you supply a string that begins and ends with a "/" it will be matched as a regex.
     */
    userData: string;
    /**
     * Match against this string. If you supply a string that begins and ends with a "/" it will be matched as a regex.
     */
    zone: string;
}

export interface GetDomainRecordFilter {
    /**
     * A regular expression to match the record content.
     */
    contentRegex?: string;
    /**
     * The record ID to match.
     */
    id?: string;
    /**
     * The domain record name to match.
     */
    name?: string;
    /**
     * The record type to match.
     */
    recordType?: string;
}

export interface GetDomainRecordRecord {
    content?: string;
    /**
     * The exoscale.Domain name to match.
     */
    domain?: string;
    /**
     * The ID of this resource.
     */
    id?: string;
    name?: string;
    prio?: number;
    recordType?: string;
    ttl?: number;
}

export interface GetElasticIPHealthcheck {
    interval: number;
    mode: string;
    port: number;
    strikesFail: number;
    strikesOk: number;
    timeout: number;
    tlsSkipVerify: boolean;
    tlsSni: string;
    uri: string;
}

export interface GetInstancePoolInstance {
    /**
     * The instance pool ID to match (conflicts with `name`).
     */
    id?: string;
    ipv6Address: string;
    /**
     * The pool name to match (conflicts with `id`).
     */
    name?: string;
    publicIpAddress: string;
}

export interface GetInstancePoolListPool {
    affinityGroupIds: string[];
    deployTargetId: string;
    description: string;
    diskSize: number;
    elasticIpIds: string[];
    /**
     * The ID of this resource.
     */
    id?: string;
    instancePrefix: string;
    instanceType: string;
    instances: outputs.GetInstancePoolListPoolInstance[];
    ipv6: boolean;
    keyPair: string;
    labels?: {[key: string]: string};
    name?: string;
    networkIds: string[];
    securityGroupIds: string[];
    size: number;
    state: string;
    templateId: string;
    userData: string;
    /**
     * The Exoscale [Zone](https://www.exoscale.com/datacenters/) name.
     */
    zone: string;
}

export interface GetInstancePoolListPoolInstance {
    /**
     * The ID of this resource.
     */
    id?: string;
    ipv6Address: string;
    name?: string;
    publicIpAddress: string;
}

export interface GetSKSClusterListCluster {
    /**
     * @deprecated This attribute has been replaced by `exoscale_ccm`/`metrics_server` attributes, it will be removed in a future release.
     */
    addons: string[];
    /**
     * Match against this string. If you supply a string that begins and ends with a "/" it will be matched as a regex.
     */
    aggregationCa: string;
    /**
     * Match against this bool
     */
    autoUpgrade?: boolean;
    /**
     * Match against this string. If you supply a string that begins and ends with a "/" it will be matched as a regex.
     */
    cni?: string;
    /**
     * Match against this string. If you supply a string that begins and ends with a "/" it will be matched as a regex.
     */
    controlPlaneCa: string;
    /**
     * Match against this string. If you supply a string that begins and ends with a "/" it will be matched as a regex.
     */
    createdAt: string;
    /**
     * Match against this string. If you supply a string that begins and ends with a "/" it will be matched as a regex.
     */
    description?: string;
    /**
     * Match against this string. If you supply a string that begins and ends with a "/" it will be matched as a regex.
     */
    endpoint: string;
    /**
     * Match against this bool
     */
    exoscaleCcm?: boolean;
    /**
     * Match against this string. If you supply a string that begins and ends with a "/" it will be matched as a regex.
     */
    id?: string;
    /**
     * Match against this string. If you supply a string that begins and ends with a "/" it will be matched as a regex.
     */
    kubeletCa: string;
    /**
     * Match against key/values. Keys are matched exactly, while values may be matched as a regex if you supply a string that begins and ends with "/"
     */
    labels?: {[key: string]: string};
    /**
     * Match against this bool
     */
    metricsServer?: boolean;
    /**
     * Match against this string. If you supply a string that begins and ends with a "/" it will be matched as a regex.
     */
    name?: string;
    nodepools: string[];
    oidc: outputs.GetSKSClusterListClusterOidc;
    /**
     * Match against this string. If you supply a string that begins and ends with a "/" it will be matched as a regex.
     */
    serviceLevel?: string;
    /**
     * Match against this string. If you supply a string that begins and ends with a "/" it will be matched as a regex.
     */
    state: string;
    /**
     * Match against this string. If you supply a string that begins and ends with a "/" it will be matched as a regex.
     */
    version: string;
    /**
     * Match against this string. If you supply a string that begins and ends with a "/" it will be matched as a regex.
     */
    zone: string;
}

export interface GetSKSClusterListClusterOidc {
    clientId: string;
    groupsClaim?: string;
    groupsPrefix?: string;
    issuerUrl: string;
    requiredClaim?: {[key: string]: string};
    usernameClaim?: string;
    usernamePrefix?: string;
}

export interface GetSKSClusterOidc {
    /**
     * The OpenID client ID.
     */
    clientId: string;
    /**
     * An OpenID JWT claim to use as the user's group.
     */
    groupsClaim?: string;
    /**
     * An OpenID prefix prepended to group claims.
     */
    groupsPrefix?: string;
    /**
     * The OpenID provider URL.
     */
    issuerUrl: string;
    /**
     * A map of key/value pairs that describes a required claim in the OpenID Token.
     */
    requiredClaim?: {[key: string]: string};
    /**
     * An OpenID JWT claim to use as the user name.
     */
    usernameClaim?: string;
    /**
     * An OpenID prefix prepended to username claims.
     */
    usernamePrefix?: string;
}

export interface GetSKSNodepoolListNodepool {
    antiAffinityGroupIds?: string[];
    /**
     * Match against this string. If you supply a string that begins and ends with a "/" it will be matched as a regex.
     */
    clusterId: string;
    /**
     * Match against this string. If you supply a string that begins and ends with a "/" it will be matched as a regex.
     */
    createdAt: string;
    /**
     * Match against this string. If you supply a string that begins and ends with a "/" it will be matched as a regex.
     */
    deployTargetId?: string;
    /**
     * Match against this string. If you supply a string that begins and ends with a "/" it will be matched as a regex.
     */
    description?: string;
    /**
     * Match against this int
     */
    diskSize?: number;
    /**
     * Match against this string. If you supply a string that begins and ends with a "/" it will be matched as a regex.
     */
    id?: string;
    /**
     * Match against this string. If you supply a string that begins and ends with a "/" it will be matched as a regex.
     */
    instancePoolId: string;
    /**
     * Match against this string. If you supply a string that begins and ends with a "/" it will be matched as a regex.
     */
    instancePrefix?: string;
    /**
     * Match against this string. If you supply a string that begins and ends with a "/" it will be matched as a regex.
     */
    instanceType?: string;
    /**
     * Match against key/values. Keys are matched exactly, while values may be matched as a regex if you supply a string that begins and ends with "/"
     */
    labels?: {[key: string]: string};
    /**
     * Match against this string. If you supply a string that begins and ends with a "/" it will be matched as a regex.
     */
    name?: string;
    privateNetworkIds?: string[];
    securityGroupIds?: string[];
    /**
     * Match against this int
     */
    size?: number;
    /**
     * Match against this string. If you supply a string that begins and ends with a "/" it will be matched as a regex.
     */
    state: string;
    /**
     * Match against key/values. Keys are matched exactly, while values may be matched as a regex if you supply a string that begins and ends with "/"
     */
    taints?: {[key: string]: string};
    /**
     * Match against this string. If you supply a string that begins and ends with a "/" it will be matched as a regex.
     */
    templateId: string;
    /**
     * Match against this string. If you supply a string that begins and ends with a "/" it will be matched as a regex.
     */
    version: string;
    /**
     * Match against this string. If you supply a string that begins and ends with a "/" it will be matched as a regex.
     */
    zone: string;
}

export interface InstancePoolInstance {
    id?: string;
    ipv6Address: string;
    name?: string;
    publicIpAddress: string;
}

export interface NLBServiceHealthcheck {
    interval?: number;
    mode?: string;
    port: number;
    retries?: number;
    timeout?: number;
    tlsSni?: string;
    uri?: string;
}

export interface SKSClusterOidc {
    clientId: string;
    groupsClaim?: string;
    groupsPrefix?: string;
    issuerUrl: string;
    requiredClaim?: {[key: string]: string};
    usernameClaim?: string;
    usernamePrefix?: string;
}

export interface SecurityGroupRulesEgress {
    cidrLists?: string[];
    description?: string;
    icmpCode?: number;
    icmpType?: number;
    ids: string[];
    ports?: string[];
    protocol?: string;
    userSecurityGroupLists?: string[];
}

export interface SecurityGroupRulesIngress {
    cidrLists?: string[];
    description?: string;
    icmpCode?: number;
    icmpType?: number;
    ids: string[];
    ports?: string[];
    protocol?: string;
    userSecurityGroupLists?: string[];
}

