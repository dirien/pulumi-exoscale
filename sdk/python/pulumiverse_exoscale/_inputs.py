# coding=utf-8
# *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import copy
import warnings
import pulumi
import pulumi.runtime
from typing import Any, Callable, Mapping, Optional, Sequence, Union, overload
from . import _utilities

__all__ = [
    'DatabaseGrafanaArgs',
    'DatabaseKafkaArgs',
    'DatabaseMysqlArgs',
    'DatabaseOpensearchArgs',
    'DatabaseOpensearchDashboardsArgs',
    'DatabaseOpensearchIndexPatternArgs',
    'DatabaseOpensearchIndexTemplateArgs',
    'DatabasePgArgs',
    'DatabaseRedisArgs',
    'DatabaseTimeoutsArgs',
    'GetDatabaseURITimeoutsArgs',
    'GetNLBServiceListTimeoutsArgs',
]

@pulumi.input_type
class DatabaseGrafanaArgs:
    def __init__(__self__, *,
                 grafana_settings: Optional[pulumi.Input[str]] = None,
                 ip_filters: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[str] grafana_settings: Grafana configuration settings in JSON format (`exo dbaas type show grafana --settings=grafana` for reference).
        :param pulumi.Input[Sequence[pulumi.Input[str]]] ip_filters: A list of CIDR blocks to allow incoming connections from.
        """
        DatabaseGrafanaArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            grafana_settings=grafana_settings,
            ip_filters=ip_filters,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             grafana_settings: Optional[pulumi.Input[str]] = None,
             ip_filters: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if grafana_settings is not None:
            _setter("grafana_settings", grafana_settings)
        if ip_filters is not None:
            _setter("ip_filters", ip_filters)

    @property
    @pulumi.getter(name="grafanaSettings")
    def grafana_settings(self) -> Optional[pulumi.Input[str]]:
        """
        Grafana configuration settings in JSON format (`exo dbaas type show grafana --settings=grafana` for reference).
        """
        return pulumi.get(self, "grafana_settings")

    @grafana_settings.setter
    def grafana_settings(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "grafana_settings", value)

    @property
    @pulumi.getter(name="ipFilters")
    def ip_filters(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        A list of CIDR blocks to allow incoming connections from.
        """
        return pulumi.get(self, "ip_filters")

    @ip_filters.setter
    def ip_filters(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "ip_filters", value)


@pulumi.input_type
class DatabaseKafkaArgs:
    def __init__(__self__, *,
                 enable_cert_auth: Optional[pulumi.Input[bool]] = None,
                 enable_kafka_connect: Optional[pulumi.Input[bool]] = None,
                 enable_kafka_rest: Optional[pulumi.Input[bool]] = None,
                 enable_sasl_auth: Optional[pulumi.Input[bool]] = None,
                 enable_schema_registry: Optional[pulumi.Input[bool]] = None,
                 ip_filters: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 kafka_connect_settings: Optional[pulumi.Input[str]] = None,
                 kafka_rest_settings: Optional[pulumi.Input[str]] = None,
                 kafka_settings: Optional[pulumi.Input[str]] = None,
                 schema_registry_settings: Optional[pulumi.Input[str]] = None,
                 version: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[bool] enable_cert_auth: Enable certificate-based authentication method.
        :param pulumi.Input[bool] enable_kafka_connect: Enable Kafka Connect.
        :param pulumi.Input[bool] enable_kafka_rest: Enable Kafka REST.
        :param pulumi.Input[bool] enable_sasl_auth: Enable SASL-based authentication method.
        :param pulumi.Input[bool] enable_schema_registry: Enable Schema Registry.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] ip_filters: A list of CIDR blocks to allow incoming connections from.
        :param pulumi.Input[str] kafka_connect_settings: Kafka Connect configuration settings in JSON format (`exo dbaas type show kafka --settings=kafka-connect` for reference).
        :param pulumi.Input[str] kafka_rest_settings: Kafka REST configuration settings in JSON format (`exo dbaas type show kafka --settings=kafka-rest` for reference).
        :param pulumi.Input[str] kafka_settings: Kafka configuration settings in JSON format (`exo dbaas type show kafka --settings=kafka` for reference).
        :param pulumi.Input[str] schema_registry_settings: Schema Registry configuration settings in JSON format (`exo dbaas type show kafka --settings=schema-registry` for reference)
        :param pulumi.Input[str] version: Kafka major version (`exo dbaas type show kafka` for reference; may only be set at creation time).
        """
        DatabaseKafkaArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            enable_cert_auth=enable_cert_auth,
            enable_kafka_connect=enable_kafka_connect,
            enable_kafka_rest=enable_kafka_rest,
            enable_sasl_auth=enable_sasl_auth,
            enable_schema_registry=enable_schema_registry,
            ip_filters=ip_filters,
            kafka_connect_settings=kafka_connect_settings,
            kafka_rest_settings=kafka_rest_settings,
            kafka_settings=kafka_settings,
            schema_registry_settings=schema_registry_settings,
            version=version,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             enable_cert_auth: Optional[pulumi.Input[bool]] = None,
             enable_kafka_connect: Optional[pulumi.Input[bool]] = None,
             enable_kafka_rest: Optional[pulumi.Input[bool]] = None,
             enable_sasl_auth: Optional[pulumi.Input[bool]] = None,
             enable_schema_registry: Optional[pulumi.Input[bool]] = None,
             ip_filters: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
             kafka_connect_settings: Optional[pulumi.Input[str]] = None,
             kafka_rest_settings: Optional[pulumi.Input[str]] = None,
             kafka_settings: Optional[pulumi.Input[str]] = None,
             schema_registry_settings: Optional[pulumi.Input[str]] = None,
             version: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if enable_cert_auth is not None:
            _setter("enable_cert_auth", enable_cert_auth)
        if enable_kafka_connect is not None:
            _setter("enable_kafka_connect", enable_kafka_connect)
        if enable_kafka_rest is not None:
            _setter("enable_kafka_rest", enable_kafka_rest)
        if enable_sasl_auth is not None:
            _setter("enable_sasl_auth", enable_sasl_auth)
        if enable_schema_registry is not None:
            _setter("enable_schema_registry", enable_schema_registry)
        if ip_filters is not None:
            _setter("ip_filters", ip_filters)
        if kafka_connect_settings is not None:
            _setter("kafka_connect_settings", kafka_connect_settings)
        if kafka_rest_settings is not None:
            _setter("kafka_rest_settings", kafka_rest_settings)
        if kafka_settings is not None:
            _setter("kafka_settings", kafka_settings)
        if schema_registry_settings is not None:
            _setter("schema_registry_settings", schema_registry_settings)
        if version is not None:
            _setter("version", version)

    @property
    @pulumi.getter(name="enableCertAuth")
    def enable_cert_auth(self) -> Optional[pulumi.Input[bool]]:
        """
        Enable certificate-based authentication method.
        """
        return pulumi.get(self, "enable_cert_auth")

    @enable_cert_auth.setter
    def enable_cert_auth(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enable_cert_auth", value)

    @property
    @pulumi.getter(name="enableKafkaConnect")
    def enable_kafka_connect(self) -> Optional[pulumi.Input[bool]]:
        """
        Enable Kafka Connect.
        """
        return pulumi.get(self, "enable_kafka_connect")

    @enable_kafka_connect.setter
    def enable_kafka_connect(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enable_kafka_connect", value)

    @property
    @pulumi.getter(name="enableKafkaRest")
    def enable_kafka_rest(self) -> Optional[pulumi.Input[bool]]:
        """
        Enable Kafka REST.
        """
        return pulumi.get(self, "enable_kafka_rest")

    @enable_kafka_rest.setter
    def enable_kafka_rest(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enable_kafka_rest", value)

    @property
    @pulumi.getter(name="enableSaslAuth")
    def enable_sasl_auth(self) -> Optional[pulumi.Input[bool]]:
        """
        Enable SASL-based authentication method.
        """
        return pulumi.get(self, "enable_sasl_auth")

    @enable_sasl_auth.setter
    def enable_sasl_auth(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enable_sasl_auth", value)

    @property
    @pulumi.getter(name="enableSchemaRegistry")
    def enable_schema_registry(self) -> Optional[pulumi.Input[bool]]:
        """
        Enable Schema Registry.
        """
        return pulumi.get(self, "enable_schema_registry")

    @enable_schema_registry.setter
    def enable_schema_registry(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enable_schema_registry", value)

    @property
    @pulumi.getter(name="ipFilters")
    def ip_filters(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        A list of CIDR blocks to allow incoming connections from.
        """
        return pulumi.get(self, "ip_filters")

    @ip_filters.setter
    def ip_filters(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "ip_filters", value)

    @property
    @pulumi.getter(name="kafkaConnectSettings")
    def kafka_connect_settings(self) -> Optional[pulumi.Input[str]]:
        """
        Kafka Connect configuration settings in JSON format (`exo dbaas type show kafka --settings=kafka-connect` for reference).
        """
        return pulumi.get(self, "kafka_connect_settings")

    @kafka_connect_settings.setter
    def kafka_connect_settings(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "kafka_connect_settings", value)

    @property
    @pulumi.getter(name="kafkaRestSettings")
    def kafka_rest_settings(self) -> Optional[pulumi.Input[str]]:
        """
        Kafka REST configuration settings in JSON format (`exo dbaas type show kafka --settings=kafka-rest` for reference).
        """
        return pulumi.get(self, "kafka_rest_settings")

    @kafka_rest_settings.setter
    def kafka_rest_settings(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "kafka_rest_settings", value)

    @property
    @pulumi.getter(name="kafkaSettings")
    def kafka_settings(self) -> Optional[pulumi.Input[str]]:
        """
        Kafka configuration settings in JSON format (`exo dbaas type show kafka --settings=kafka` for reference).
        """
        return pulumi.get(self, "kafka_settings")

    @kafka_settings.setter
    def kafka_settings(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "kafka_settings", value)

    @property
    @pulumi.getter(name="schemaRegistrySettings")
    def schema_registry_settings(self) -> Optional[pulumi.Input[str]]:
        """
        Schema Registry configuration settings in JSON format (`exo dbaas type show kafka --settings=schema-registry` for reference)
        """
        return pulumi.get(self, "schema_registry_settings")

    @schema_registry_settings.setter
    def schema_registry_settings(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "schema_registry_settings", value)

    @property
    @pulumi.getter
    def version(self) -> Optional[pulumi.Input[str]]:
        """
        Kafka major version (`exo dbaas type show kafka` for reference; may only be set at creation time).
        """
        return pulumi.get(self, "version")

    @version.setter
    def version(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "version", value)


@pulumi.input_type
class DatabaseMysqlArgs:
    def __init__(__self__, *,
                 admin_password: Optional[pulumi.Input[str]] = None,
                 admin_username: Optional[pulumi.Input[str]] = None,
                 backup_schedule: Optional[pulumi.Input[str]] = None,
                 ip_filters: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 mysql_settings: Optional[pulumi.Input[str]] = None,
                 version: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] admin_password: A custom administrator account password (may only be set at creation time).
        :param pulumi.Input[str] admin_username: A custom administrator account username (may only be set at creation time).
        :param pulumi.Input[str] backup_schedule: The automated backup schedule (`HH:MM`).
        :param pulumi.Input[Sequence[pulumi.Input[str]]] ip_filters: A list of CIDR blocks to allow incoming connections from.
        :param pulumi.Input[str] mysql_settings: MySQL configuration settings in JSON format (`exo dbaas type show mysql --settings=mysql` for reference).
        :param pulumi.Input[str] version: MySQL major version (`exo dbaas type show mysql` for reference; may only be set at creation time).
        """
        DatabaseMysqlArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            admin_password=admin_password,
            admin_username=admin_username,
            backup_schedule=backup_schedule,
            ip_filters=ip_filters,
            mysql_settings=mysql_settings,
            version=version,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             admin_password: Optional[pulumi.Input[str]] = None,
             admin_username: Optional[pulumi.Input[str]] = None,
             backup_schedule: Optional[pulumi.Input[str]] = None,
             ip_filters: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
             mysql_settings: Optional[pulumi.Input[str]] = None,
             version: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if admin_password is not None:
            _setter("admin_password", admin_password)
        if admin_username is not None:
            _setter("admin_username", admin_username)
        if backup_schedule is not None:
            _setter("backup_schedule", backup_schedule)
        if ip_filters is not None:
            _setter("ip_filters", ip_filters)
        if mysql_settings is not None:
            _setter("mysql_settings", mysql_settings)
        if version is not None:
            _setter("version", version)

    @property
    @pulumi.getter(name="adminPassword")
    def admin_password(self) -> Optional[pulumi.Input[str]]:
        """
        A custom administrator account password (may only be set at creation time).
        """
        return pulumi.get(self, "admin_password")

    @admin_password.setter
    def admin_password(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "admin_password", value)

    @property
    @pulumi.getter(name="adminUsername")
    def admin_username(self) -> Optional[pulumi.Input[str]]:
        """
        A custom administrator account username (may only be set at creation time).
        """
        return pulumi.get(self, "admin_username")

    @admin_username.setter
    def admin_username(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "admin_username", value)

    @property
    @pulumi.getter(name="backupSchedule")
    def backup_schedule(self) -> Optional[pulumi.Input[str]]:
        """
        The automated backup schedule (`HH:MM`).
        """
        return pulumi.get(self, "backup_schedule")

    @backup_schedule.setter
    def backup_schedule(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "backup_schedule", value)

    @property
    @pulumi.getter(name="ipFilters")
    def ip_filters(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        A list of CIDR blocks to allow incoming connections from.
        """
        return pulumi.get(self, "ip_filters")

    @ip_filters.setter
    def ip_filters(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "ip_filters", value)

    @property
    @pulumi.getter(name="mysqlSettings")
    def mysql_settings(self) -> Optional[pulumi.Input[str]]:
        """
        MySQL configuration settings in JSON format (`exo dbaas type show mysql --settings=mysql` for reference).
        """
        return pulumi.get(self, "mysql_settings")

    @mysql_settings.setter
    def mysql_settings(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "mysql_settings", value)

    @property
    @pulumi.getter
    def version(self) -> Optional[pulumi.Input[str]]:
        """
        MySQL major version (`exo dbaas type show mysql` for reference; may only be set at creation time).
        """
        return pulumi.get(self, "version")

    @version.setter
    def version(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "version", value)


@pulumi.input_type
class DatabaseOpensearchArgs:
    def __init__(__self__, *,
                 dashboards: Optional[pulumi.Input['DatabaseOpensearchDashboardsArgs']] = None,
                 fork_from_service: Optional[pulumi.Input[str]] = None,
                 index_patterns: Optional[pulumi.Input[Sequence[pulumi.Input['DatabaseOpensearchIndexPatternArgs']]]] = None,
                 index_template: Optional[pulumi.Input['DatabaseOpensearchIndexTemplateArgs']] = None,
                 ip_filters: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 keep_index_refresh_interval: Optional[pulumi.Input[bool]] = None,
                 max_index_count: Optional[pulumi.Input[int]] = None,
                 recovery_backup_name: Optional[pulumi.Input[str]] = None,
                 settings: Optional[pulumi.Input[str]] = None,
                 version: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input['DatabaseOpensearchDashboardsArgs'] dashboards: OpenSearch Dashboards settings
        :param pulumi.Input[str] fork_from_service: ❗ Service name
        :param pulumi.Input[Sequence[pulumi.Input['DatabaseOpensearchIndexPatternArgs']]] index_patterns: (can be used multiple times) Allows you to create glob style patterns and set a max number of indexes matching this pattern you want to keep. Creating indexes exceeding this value will cause the oldest one to get deleted. You could for example create a pattern looking like 'logs.?' and then create index logs.1, logs.2 etc, it will delete logs.1 once you create logs.6. Do note 'logs.?' does not apply to logs.10. Note: Setting max*index*count to 0 will do nothing and the pattern gets ignored.
        :param pulumi.Input['DatabaseOpensearchIndexTemplateArgs'] index_template: Template settings for all new indexes
        :param pulumi.Input[Sequence[pulumi.Input[str]]] ip_filters: Allow incoming connections from this list of CIDR address block, e.g. `["10.20.0.0/16"]
        :param pulumi.Input[bool] keep_index_refresh_interval: Aiven automation resets index.refresh_interval to default value for every index to be sure that indices are always visible to search. If it doesn't fit your case, you can disable this by setting up this flag to true.
        :param pulumi.Input[int] max_index_count: Maximum number of indexes to keep (Minimum value is `0`)
        :param pulumi.Input[str] recovery_backup_name: ❗ Name of a backup to recover from
        :param pulumi.Input[str] settings: OpenSearch-specific settings, in json. e.g.`jsonencode({thread_pool_search_size: 64})`. Use `exo x get-dbaas-settings-opensearch` to get a list of available settings.
        :param pulumi.Input[str] version: ❗ OpenSearch major version (`exo dbaas type show opensearch` for reference)
        """
        DatabaseOpensearchArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            dashboards=dashboards,
            fork_from_service=fork_from_service,
            index_patterns=index_patterns,
            index_template=index_template,
            ip_filters=ip_filters,
            keep_index_refresh_interval=keep_index_refresh_interval,
            max_index_count=max_index_count,
            recovery_backup_name=recovery_backup_name,
            settings=settings,
            version=version,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             dashboards: Optional[pulumi.Input['DatabaseOpensearchDashboardsArgs']] = None,
             fork_from_service: Optional[pulumi.Input[str]] = None,
             index_patterns: Optional[pulumi.Input[Sequence[pulumi.Input['DatabaseOpensearchIndexPatternArgs']]]] = None,
             index_template: Optional[pulumi.Input['DatabaseOpensearchIndexTemplateArgs']] = None,
             ip_filters: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
             keep_index_refresh_interval: Optional[pulumi.Input[bool]] = None,
             max_index_count: Optional[pulumi.Input[int]] = None,
             recovery_backup_name: Optional[pulumi.Input[str]] = None,
             settings: Optional[pulumi.Input[str]] = None,
             version: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if dashboards is not None:
            _setter("dashboards", dashboards)
        if fork_from_service is not None:
            _setter("fork_from_service", fork_from_service)
        if index_patterns is not None:
            _setter("index_patterns", index_patterns)
        if index_template is not None:
            _setter("index_template", index_template)
        if ip_filters is not None:
            _setter("ip_filters", ip_filters)
        if keep_index_refresh_interval is not None:
            _setter("keep_index_refresh_interval", keep_index_refresh_interval)
        if max_index_count is not None:
            _setter("max_index_count", max_index_count)
        if recovery_backup_name is not None:
            _setter("recovery_backup_name", recovery_backup_name)
        if settings is not None:
            _setter("settings", settings)
        if version is not None:
            _setter("version", version)

    @property
    @pulumi.getter
    def dashboards(self) -> Optional[pulumi.Input['DatabaseOpensearchDashboardsArgs']]:
        """
        OpenSearch Dashboards settings
        """
        return pulumi.get(self, "dashboards")

    @dashboards.setter
    def dashboards(self, value: Optional[pulumi.Input['DatabaseOpensearchDashboardsArgs']]):
        pulumi.set(self, "dashboards", value)

    @property
    @pulumi.getter(name="forkFromService")
    def fork_from_service(self) -> Optional[pulumi.Input[str]]:
        """
        ❗ Service name
        """
        return pulumi.get(self, "fork_from_service")

    @fork_from_service.setter
    def fork_from_service(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "fork_from_service", value)

    @property
    @pulumi.getter(name="indexPatterns")
    def index_patterns(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['DatabaseOpensearchIndexPatternArgs']]]]:
        """
        (can be used multiple times) Allows you to create glob style patterns and set a max number of indexes matching this pattern you want to keep. Creating indexes exceeding this value will cause the oldest one to get deleted. You could for example create a pattern looking like 'logs.?' and then create index logs.1, logs.2 etc, it will delete logs.1 once you create logs.6. Do note 'logs.?' does not apply to logs.10. Note: Setting max*index*count to 0 will do nothing and the pattern gets ignored.
        """
        return pulumi.get(self, "index_patterns")

    @index_patterns.setter
    def index_patterns(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['DatabaseOpensearchIndexPatternArgs']]]]):
        pulumi.set(self, "index_patterns", value)

    @property
    @pulumi.getter(name="indexTemplate")
    def index_template(self) -> Optional[pulumi.Input['DatabaseOpensearchIndexTemplateArgs']]:
        """
        Template settings for all new indexes
        """
        return pulumi.get(self, "index_template")

    @index_template.setter
    def index_template(self, value: Optional[pulumi.Input['DatabaseOpensearchIndexTemplateArgs']]):
        pulumi.set(self, "index_template", value)

    @property
    @pulumi.getter(name="ipFilters")
    def ip_filters(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Allow incoming connections from this list of CIDR address block, e.g. `["10.20.0.0/16"]
        """
        return pulumi.get(self, "ip_filters")

    @ip_filters.setter
    def ip_filters(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "ip_filters", value)

    @property
    @pulumi.getter(name="keepIndexRefreshInterval")
    def keep_index_refresh_interval(self) -> Optional[pulumi.Input[bool]]:
        """
        Aiven automation resets index.refresh_interval to default value for every index to be sure that indices are always visible to search. If it doesn't fit your case, you can disable this by setting up this flag to true.
        """
        return pulumi.get(self, "keep_index_refresh_interval")

    @keep_index_refresh_interval.setter
    def keep_index_refresh_interval(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "keep_index_refresh_interval", value)

    @property
    @pulumi.getter(name="maxIndexCount")
    def max_index_count(self) -> Optional[pulumi.Input[int]]:
        """
        Maximum number of indexes to keep (Minimum value is `0`)
        """
        return pulumi.get(self, "max_index_count")

    @max_index_count.setter
    def max_index_count(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "max_index_count", value)

    @property
    @pulumi.getter(name="recoveryBackupName")
    def recovery_backup_name(self) -> Optional[pulumi.Input[str]]:
        """
        ❗ Name of a backup to recover from
        """
        return pulumi.get(self, "recovery_backup_name")

    @recovery_backup_name.setter
    def recovery_backup_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "recovery_backup_name", value)

    @property
    @pulumi.getter
    def settings(self) -> Optional[pulumi.Input[str]]:
        """
        OpenSearch-specific settings, in json. e.g.`jsonencode({thread_pool_search_size: 64})`. Use `exo x get-dbaas-settings-opensearch` to get a list of available settings.
        """
        return pulumi.get(self, "settings")

    @settings.setter
    def settings(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "settings", value)

    @property
    @pulumi.getter
    def version(self) -> Optional[pulumi.Input[str]]:
        """
        ❗ OpenSearch major version (`exo dbaas type show opensearch` for reference)
        """
        return pulumi.get(self, "version")

    @version.setter
    def version(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "version", value)


@pulumi.input_type
class DatabaseOpensearchDashboardsArgs:
    def __init__(__self__, *,
                 enabled: Optional[pulumi.Input[bool]] = None,
                 max_old_space_size: Optional[pulumi.Input[int]] = None,
                 request_timeout: Optional[pulumi.Input[int]] = None):
        DatabaseOpensearchDashboardsArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            enabled=enabled,
            max_old_space_size=max_old_space_size,
            request_timeout=request_timeout,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             enabled: Optional[pulumi.Input[bool]] = None,
             max_old_space_size: Optional[pulumi.Input[int]] = None,
             request_timeout: Optional[pulumi.Input[int]] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if enabled is not None:
            _setter("enabled", enabled)
        if max_old_space_size is not None:
            _setter("max_old_space_size", max_old_space_size)
        if request_timeout is not None:
            _setter("request_timeout", request_timeout)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter(name="maxOldSpaceSize")
    def max_old_space_size(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "max_old_space_size")

    @max_old_space_size.setter
    def max_old_space_size(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "max_old_space_size", value)

    @property
    @pulumi.getter(name="requestTimeout")
    def request_timeout(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "request_timeout")

    @request_timeout.setter
    def request_timeout(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "request_timeout", value)


@pulumi.input_type
class DatabaseOpensearchIndexPatternArgs:
    def __init__(__self__, *,
                 max_index_count: Optional[pulumi.Input[int]] = None,
                 pattern: Optional[pulumi.Input[str]] = None,
                 sorting_algorithm: Optional[pulumi.Input[str]] = None):
        DatabaseOpensearchIndexPatternArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            max_index_count=max_index_count,
            pattern=pattern,
            sorting_algorithm=sorting_algorithm,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             max_index_count: Optional[pulumi.Input[int]] = None,
             pattern: Optional[pulumi.Input[str]] = None,
             sorting_algorithm: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if max_index_count is not None:
            _setter("max_index_count", max_index_count)
        if pattern is not None:
            _setter("pattern", pattern)
        if sorting_algorithm is not None:
            _setter("sorting_algorithm", sorting_algorithm)

    @property
    @pulumi.getter(name="maxIndexCount")
    def max_index_count(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "max_index_count")

    @max_index_count.setter
    def max_index_count(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "max_index_count", value)

    @property
    @pulumi.getter
    def pattern(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "pattern")

    @pattern.setter
    def pattern(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "pattern", value)

    @property
    @pulumi.getter(name="sortingAlgorithm")
    def sorting_algorithm(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "sorting_algorithm")

    @sorting_algorithm.setter
    def sorting_algorithm(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "sorting_algorithm", value)


@pulumi.input_type
class DatabaseOpensearchIndexTemplateArgs:
    def __init__(__self__, *,
                 mapping_nested_objects_limit: Optional[pulumi.Input[int]] = None,
                 number_of_replicas: Optional[pulumi.Input[int]] = None,
                 number_of_shards: Optional[pulumi.Input[int]] = None):
        DatabaseOpensearchIndexTemplateArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            mapping_nested_objects_limit=mapping_nested_objects_limit,
            number_of_replicas=number_of_replicas,
            number_of_shards=number_of_shards,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             mapping_nested_objects_limit: Optional[pulumi.Input[int]] = None,
             number_of_replicas: Optional[pulumi.Input[int]] = None,
             number_of_shards: Optional[pulumi.Input[int]] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if mapping_nested_objects_limit is not None:
            _setter("mapping_nested_objects_limit", mapping_nested_objects_limit)
        if number_of_replicas is not None:
            _setter("number_of_replicas", number_of_replicas)
        if number_of_shards is not None:
            _setter("number_of_shards", number_of_shards)

    @property
    @pulumi.getter(name="mappingNestedObjectsLimit")
    def mapping_nested_objects_limit(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "mapping_nested_objects_limit")

    @mapping_nested_objects_limit.setter
    def mapping_nested_objects_limit(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "mapping_nested_objects_limit", value)

    @property
    @pulumi.getter(name="numberOfReplicas")
    def number_of_replicas(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "number_of_replicas")

    @number_of_replicas.setter
    def number_of_replicas(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "number_of_replicas", value)

    @property
    @pulumi.getter(name="numberOfShards")
    def number_of_shards(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "number_of_shards")

    @number_of_shards.setter
    def number_of_shards(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "number_of_shards", value)


@pulumi.input_type
class DatabasePgArgs:
    def __init__(__self__, *,
                 admin_password: Optional[pulumi.Input[str]] = None,
                 admin_username: Optional[pulumi.Input[str]] = None,
                 backup_schedule: Optional[pulumi.Input[str]] = None,
                 ip_filters: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 pg_settings: Optional[pulumi.Input[str]] = None,
                 pgbouncer_settings: Optional[pulumi.Input[str]] = None,
                 pglookout_settings: Optional[pulumi.Input[str]] = None,
                 version: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] admin_password: A custom administrator account password (may only be set at creation time).
        :param pulumi.Input[str] admin_username: A custom administrator account username (may only be set at creation time).
        :param pulumi.Input[str] backup_schedule: The automated backup schedule (`HH:MM`).
        :param pulumi.Input[Sequence[pulumi.Input[str]]] ip_filters: A list of CIDR blocks to allow incoming connections from.
        :param pulumi.Input[str] pg_settings: PostgreSQL configuration settings in JSON format (`exo dbaas type show pg --settings=pg` for reference).
        :param pulumi.Input[str] pgbouncer_settings: PgBouncer configuration settings in JSON format (`exo dbaas type show pg --settings=pgbouncer` for reference).
        :param pulumi.Input[str] pglookout_settings: pglookout configuration settings in JSON format (`exo dbaas type show pg --settings=pglookout` for reference).
        :param pulumi.Input[str] version: PostgreSQL major version (`exo dbaas type show pg` for reference; may only be set at creation time).
        """
        DatabasePgArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            admin_password=admin_password,
            admin_username=admin_username,
            backup_schedule=backup_schedule,
            ip_filters=ip_filters,
            pg_settings=pg_settings,
            pgbouncer_settings=pgbouncer_settings,
            pglookout_settings=pglookout_settings,
            version=version,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             admin_password: Optional[pulumi.Input[str]] = None,
             admin_username: Optional[pulumi.Input[str]] = None,
             backup_schedule: Optional[pulumi.Input[str]] = None,
             ip_filters: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
             pg_settings: Optional[pulumi.Input[str]] = None,
             pgbouncer_settings: Optional[pulumi.Input[str]] = None,
             pglookout_settings: Optional[pulumi.Input[str]] = None,
             version: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if admin_password is not None:
            _setter("admin_password", admin_password)
        if admin_username is not None:
            _setter("admin_username", admin_username)
        if backup_schedule is not None:
            _setter("backup_schedule", backup_schedule)
        if ip_filters is not None:
            _setter("ip_filters", ip_filters)
        if pg_settings is not None:
            _setter("pg_settings", pg_settings)
        if pgbouncer_settings is not None:
            _setter("pgbouncer_settings", pgbouncer_settings)
        if pglookout_settings is not None:
            _setter("pglookout_settings", pglookout_settings)
        if version is not None:
            _setter("version", version)

    @property
    @pulumi.getter(name="adminPassword")
    def admin_password(self) -> Optional[pulumi.Input[str]]:
        """
        A custom administrator account password (may only be set at creation time).
        """
        return pulumi.get(self, "admin_password")

    @admin_password.setter
    def admin_password(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "admin_password", value)

    @property
    @pulumi.getter(name="adminUsername")
    def admin_username(self) -> Optional[pulumi.Input[str]]:
        """
        A custom administrator account username (may only be set at creation time).
        """
        return pulumi.get(self, "admin_username")

    @admin_username.setter
    def admin_username(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "admin_username", value)

    @property
    @pulumi.getter(name="backupSchedule")
    def backup_schedule(self) -> Optional[pulumi.Input[str]]:
        """
        The automated backup schedule (`HH:MM`).
        """
        return pulumi.get(self, "backup_schedule")

    @backup_schedule.setter
    def backup_schedule(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "backup_schedule", value)

    @property
    @pulumi.getter(name="ipFilters")
    def ip_filters(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        A list of CIDR blocks to allow incoming connections from.
        """
        return pulumi.get(self, "ip_filters")

    @ip_filters.setter
    def ip_filters(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "ip_filters", value)

    @property
    @pulumi.getter(name="pgSettings")
    def pg_settings(self) -> Optional[pulumi.Input[str]]:
        """
        PostgreSQL configuration settings in JSON format (`exo dbaas type show pg --settings=pg` for reference).
        """
        return pulumi.get(self, "pg_settings")

    @pg_settings.setter
    def pg_settings(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "pg_settings", value)

    @property
    @pulumi.getter(name="pgbouncerSettings")
    def pgbouncer_settings(self) -> Optional[pulumi.Input[str]]:
        """
        PgBouncer configuration settings in JSON format (`exo dbaas type show pg --settings=pgbouncer` for reference).
        """
        return pulumi.get(self, "pgbouncer_settings")

    @pgbouncer_settings.setter
    def pgbouncer_settings(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "pgbouncer_settings", value)

    @property
    @pulumi.getter(name="pglookoutSettings")
    def pglookout_settings(self) -> Optional[pulumi.Input[str]]:
        """
        pglookout configuration settings in JSON format (`exo dbaas type show pg --settings=pglookout` for reference).
        """
        return pulumi.get(self, "pglookout_settings")

    @pglookout_settings.setter
    def pglookout_settings(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "pglookout_settings", value)

    @property
    @pulumi.getter
    def version(self) -> Optional[pulumi.Input[str]]:
        """
        PostgreSQL major version (`exo dbaas type show pg` for reference; may only be set at creation time).
        """
        return pulumi.get(self, "version")

    @version.setter
    def version(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "version", value)


@pulumi.input_type
class DatabaseRedisArgs:
    def __init__(__self__, *,
                 ip_filters: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 redis_settings: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] ip_filters: A list of CIDR blocks to allow incoming connections from.
        :param pulumi.Input[str] redis_settings: Redis configuration settings in JSON format (`exo dbaas type show redis --settings=redis` for reference).
        """
        DatabaseRedisArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            ip_filters=ip_filters,
            redis_settings=redis_settings,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             ip_filters: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
             redis_settings: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if ip_filters is not None:
            _setter("ip_filters", ip_filters)
        if redis_settings is not None:
            _setter("redis_settings", redis_settings)

    @property
    @pulumi.getter(name="ipFilters")
    def ip_filters(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        A list of CIDR blocks to allow incoming connections from.
        """
        return pulumi.get(self, "ip_filters")

    @ip_filters.setter
    def ip_filters(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "ip_filters", value)

    @property
    @pulumi.getter(name="redisSettings")
    def redis_settings(self) -> Optional[pulumi.Input[str]]:
        """
        Redis configuration settings in JSON format (`exo dbaas type show redis --settings=redis` for reference).
        """
        return pulumi.get(self, "redis_settings")

    @redis_settings.setter
    def redis_settings(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "redis_settings", value)


@pulumi.input_type
class DatabaseTimeoutsArgs:
    def __init__(__self__, *,
                 create: Optional[pulumi.Input[str]] = None,
                 delete: Optional[pulumi.Input[str]] = None,
                 read: Optional[pulumi.Input[str]] = None,
                 update: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] create: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        :param pulumi.Input[str] delete: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Setting a timeout for a Delete operation is only applicable if changes are saved into state before the destroy operation occurs.
        :param pulumi.Input[str] read: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Read operations occur during any refresh or planning operation when refresh is enabled.
        :param pulumi.Input[str] update: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        DatabaseTimeoutsArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            create=create,
            delete=delete,
            read=read,
            update=update,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             create: Optional[pulumi.Input[str]] = None,
             delete: Optional[pulumi.Input[str]] = None,
             read: Optional[pulumi.Input[str]] = None,
             update: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if create is not None:
            _setter("create", create)
        if delete is not None:
            _setter("delete", delete)
        if read is not None:
            _setter("read", read)
        if update is not None:
            _setter("update", update)

    @property
    @pulumi.getter
    def create(self) -> Optional[pulumi.Input[str]]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        return pulumi.get(self, "create")

    @create.setter
    def create(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "create", value)

    @property
    @pulumi.getter
    def delete(self) -> Optional[pulumi.Input[str]]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Setting a timeout for a Delete operation is only applicable if changes are saved into state before the destroy operation occurs.
        """
        return pulumi.get(self, "delete")

    @delete.setter
    def delete(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "delete", value)

    @property
    @pulumi.getter
    def read(self) -> Optional[pulumi.Input[str]]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Read operations occur during any refresh or planning operation when refresh is enabled.
        """
        return pulumi.get(self, "read")

    @read.setter
    def read(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "read", value)

    @property
    @pulumi.getter
    def update(self) -> Optional[pulumi.Input[str]]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        return pulumi.get(self, "update")

    @update.setter
    def update(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "update", value)


@pulumi.input_type
class GetDatabaseURITimeoutsArgs:
    def __init__(__self__, *,
                 read: Optional[str] = None):
        """
        :param str read: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Read operations occur during any refresh or planning operation when refresh is enabled.
        """
        GetDatabaseURITimeoutsArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            read=read,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             read: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if read is not None:
            _setter("read", read)

    @property
    @pulumi.getter
    def read(self) -> Optional[str]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Read operations occur during any refresh or planning operation when refresh is enabled.
        """
        return pulumi.get(self, "read")

    @read.setter
    def read(self, value: Optional[str]):
        pulumi.set(self, "read", value)


@pulumi.input_type
class GetNLBServiceListTimeoutsArgs:
    def __init__(__self__, *,
                 read: Optional[str] = None):
        """
        :param str read: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Read operations occur during any refresh or planning operation when refresh is enabled.
        """
        GetNLBServiceListTimeoutsArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            read=read,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             read: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if read is not None:
            _setter("read", read)

    @property
    @pulumi.getter
    def read(self) -> Optional[str]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Read operations occur during any refresh or planning operation when refresh is enabled.
        """
        return pulumi.get(self, "read")

    @read.setter
    def read(self, value: Optional[str]):
        pulumi.set(self, "read", value)


