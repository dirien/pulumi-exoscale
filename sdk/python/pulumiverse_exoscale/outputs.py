# coding=utf-8
# *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import copy
import warnings
import pulumi
import pulumi.runtime
from typing import Any, Callable, Mapping, Optional, Sequence, Union, overload
from . import _utilities
from . import outputs

__all__ = [
    'DatabaseGrafana',
    'DatabaseKafka',
    'DatabaseMysql',
    'DatabaseOpensearch',
    'DatabaseOpensearchDashboards',
    'DatabaseOpensearchIndexPattern',
    'DatabaseOpensearchIndexTemplate',
    'DatabasePg',
    'DatabaseRedis',
    'DatabaseTimeouts',
    'GetDatabaseURITimeoutsResult',
    'GetNLBServiceListServiceResult',
    'GetNLBServiceListServiceHealthcheckResult',
    'GetNLBServiceListTimeoutsResult',
]

@pulumi.output_type
class DatabaseGrafana(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "grafanaSettings":
            suggest = "grafana_settings"
        elif key == "ipFilters":
            suggest = "ip_filters"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DatabaseGrafana. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DatabaseGrafana.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DatabaseGrafana.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 grafana_settings: Optional[str] = None,
                 ip_filters: Optional[Sequence[str]] = None):
        """
        :param str grafana_settings: Grafana configuration settings in JSON format (`exo dbaas type show grafana --settings=grafana` for reference).
        :param Sequence[str] ip_filters: A list of CIDR blocks to allow incoming connections from.
        """
        DatabaseGrafana._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            grafana_settings=grafana_settings,
            ip_filters=ip_filters,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             grafana_settings: Optional[str] = None,
             ip_filters: Optional[Sequence[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if grafana_settings is not None:
            _setter("grafana_settings", grafana_settings)
        if ip_filters is not None:
            _setter("ip_filters", ip_filters)

    @property
    @pulumi.getter(name="grafanaSettings")
    def grafana_settings(self) -> Optional[str]:
        """
        Grafana configuration settings in JSON format (`exo dbaas type show grafana --settings=grafana` for reference).
        """
        return pulumi.get(self, "grafana_settings")

    @property
    @pulumi.getter(name="ipFilters")
    def ip_filters(self) -> Optional[Sequence[str]]:
        """
        A list of CIDR blocks to allow incoming connections from.
        """
        return pulumi.get(self, "ip_filters")


@pulumi.output_type
class DatabaseKafka(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "enableCertAuth":
            suggest = "enable_cert_auth"
        elif key == "enableKafkaConnect":
            suggest = "enable_kafka_connect"
        elif key == "enableKafkaRest":
            suggest = "enable_kafka_rest"
        elif key == "enableSaslAuth":
            suggest = "enable_sasl_auth"
        elif key == "enableSchemaRegistry":
            suggest = "enable_schema_registry"
        elif key == "ipFilters":
            suggest = "ip_filters"
        elif key == "kafkaConnectSettings":
            suggest = "kafka_connect_settings"
        elif key == "kafkaRestSettings":
            suggest = "kafka_rest_settings"
        elif key == "kafkaSettings":
            suggest = "kafka_settings"
        elif key == "schemaRegistrySettings":
            suggest = "schema_registry_settings"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DatabaseKafka. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DatabaseKafka.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DatabaseKafka.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enable_cert_auth: Optional[bool] = None,
                 enable_kafka_connect: Optional[bool] = None,
                 enable_kafka_rest: Optional[bool] = None,
                 enable_sasl_auth: Optional[bool] = None,
                 enable_schema_registry: Optional[bool] = None,
                 ip_filters: Optional[Sequence[str]] = None,
                 kafka_connect_settings: Optional[str] = None,
                 kafka_rest_settings: Optional[str] = None,
                 kafka_settings: Optional[str] = None,
                 schema_registry_settings: Optional[str] = None,
                 version: Optional[str] = None):
        """
        :param bool enable_cert_auth: Enable certificate-based authentication method.
        :param bool enable_kafka_connect: Enable Kafka Connect.
        :param bool enable_kafka_rest: Enable Kafka REST.
        :param bool enable_sasl_auth: Enable SASL-based authentication method.
        :param bool enable_schema_registry: Enable Schema Registry.
        :param Sequence[str] ip_filters: A list of CIDR blocks to allow incoming connections from.
        :param str kafka_connect_settings: Kafka Connect configuration settings in JSON format (`exo dbaas type show kafka --settings=kafka-connect` for reference).
        :param str kafka_rest_settings: Kafka REST configuration settings in JSON format (`exo dbaas type show kafka --settings=kafka-rest` for reference).
        :param str kafka_settings: Kafka configuration settings in JSON format (`exo dbaas type show kafka --settings=kafka` for reference).
        :param str schema_registry_settings: Schema Registry configuration settings in JSON format (`exo dbaas type show kafka --settings=schema-registry` for reference)
        :param str version: Kafka major version (`exo dbaas type show kafka` for reference; may only be set at creation time).
        """
        DatabaseKafka._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            enable_cert_auth=enable_cert_auth,
            enable_kafka_connect=enable_kafka_connect,
            enable_kafka_rest=enable_kafka_rest,
            enable_sasl_auth=enable_sasl_auth,
            enable_schema_registry=enable_schema_registry,
            ip_filters=ip_filters,
            kafka_connect_settings=kafka_connect_settings,
            kafka_rest_settings=kafka_rest_settings,
            kafka_settings=kafka_settings,
            schema_registry_settings=schema_registry_settings,
            version=version,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             enable_cert_auth: Optional[bool] = None,
             enable_kafka_connect: Optional[bool] = None,
             enable_kafka_rest: Optional[bool] = None,
             enable_sasl_auth: Optional[bool] = None,
             enable_schema_registry: Optional[bool] = None,
             ip_filters: Optional[Sequence[str]] = None,
             kafka_connect_settings: Optional[str] = None,
             kafka_rest_settings: Optional[str] = None,
             kafka_settings: Optional[str] = None,
             schema_registry_settings: Optional[str] = None,
             version: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if enable_cert_auth is not None:
            _setter("enable_cert_auth", enable_cert_auth)
        if enable_kafka_connect is not None:
            _setter("enable_kafka_connect", enable_kafka_connect)
        if enable_kafka_rest is not None:
            _setter("enable_kafka_rest", enable_kafka_rest)
        if enable_sasl_auth is not None:
            _setter("enable_sasl_auth", enable_sasl_auth)
        if enable_schema_registry is not None:
            _setter("enable_schema_registry", enable_schema_registry)
        if ip_filters is not None:
            _setter("ip_filters", ip_filters)
        if kafka_connect_settings is not None:
            _setter("kafka_connect_settings", kafka_connect_settings)
        if kafka_rest_settings is not None:
            _setter("kafka_rest_settings", kafka_rest_settings)
        if kafka_settings is not None:
            _setter("kafka_settings", kafka_settings)
        if schema_registry_settings is not None:
            _setter("schema_registry_settings", schema_registry_settings)
        if version is not None:
            _setter("version", version)

    @property
    @pulumi.getter(name="enableCertAuth")
    def enable_cert_auth(self) -> Optional[bool]:
        """
        Enable certificate-based authentication method.
        """
        return pulumi.get(self, "enable_cert_auth")

    @property
    @pulumi.getter(name="enableKafkaConnect")
    def enable_kafka_connect(self) -> Optional[bool]:
        """
        Enable Kafka Connect.
        """
        return pulumi.get(self, "enable_kafka_connect")

    @property
    @pulumi.getter(name="enableKafkaRest")
    def enable_kafka_rest(self) -> Optional[bool]:
        """
        Enable Kafka REST.
        """
        return pulumi.get(self, "enable_kafka_rest")

    @property
    @pulumi.getter(name="enableSaslAuth")
    def enable_sasl_auth(self) -> Optional[bool]:
        """
        Enable SASL-based authentication method.
        """
        return pulumi.get(self, "enable_sasl_auth")

    @property
    @pulumi.getter(name="enableSchemaRegistry")
    def enable_schema_registry(self) -> Optional[bool]:
        """
        Enable Schema Registry.
        """
        return pulumi.get(self, "enable_schema_registry")

    @property
    @pulumi.getter(name="ipFilters")
    def ip_filters(self) -> Optional[Sequence[str]]:
        """
        A list of CIDR blocks to allow incoming connections from.
        """
        return pulumi.get(self, "ip_filters")

    @property
    @pulumi.getter(name="kafkaConnectSettings")
    def kafka_connect_settings(self) -> Optional[str]:
        """
        Kafka Connect configuration settings in JSON format (`exo dbaas type show kafka --settings=kafka-connect` for reference).
        """
        return pulumi.get(self, "kafka_connect_settings")

    @property
    @pulumi.getter(name="kafkaRestSettings")
    def kafka_rest_settings(self) -> Optional[str]:
        """
        Kafka REST configuration settings in JSON format (`exo dbaas type show kafka --settings=kafka-rest` for reference).
        """
        return pulumi.get(self, "kafka_rest_settings")

    @property
    @pulumi.getter(name="kafkaSettings")
    def kafka_settings(self) -> Optional[str]:
        """
        Kafka configuration settings in JSON format (`exo dbaas type show kafka --settings=kafka` for reference).
        """
        return pulumi.get(self, "kafka_settings")

    @property
    @pulumi.getter(name="schemaRegistrySettings")
    def schema_registry_settings(self) -> Optional[str]:
        """
        Schema Registry configuration settings in JSON format (`exo dbaas type show kafka --settings=schema-registry` for reference)
        """
        return pulumi.get(self, "schema_registry_settings")

    @property
    @pulumi.getter
    def version(self) -> Optional[str]:
        """
        Kafka major version (`exo dbaas type show kafka` for reference; may only be set at creation time).
        """
        return pulumi.get(self, "version")


@pulumi.output_type
class DatabaseMysql(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "adminPassword":
            suggest = "admin_password"
        elif key == "adminUsername":
            suggest = "admin_username"
        elif key == "backupSchedule":
            suggest = "backup_schedule"
        elif key == "ipFilters":
            suggest = "ip_filters"
        elif key == "mysqlSettings":
            suggest = "mysql_settings"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DatabaseMysql. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DatabaseMysql.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DatabaseMysql.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 admin_password: Optional[str] = None,
                 admin_username: Optional[str] = None,
                 backup_schedule: Optional[str] = None,
                 ip_filters: Optional[Sequence[str]] = None,
                 mysql_settings: Optional[str] = None,
                 version: Optional[str] = None):
        """
        :param str admin_password: A custom administrator account password (may only be set at creation time).
        :param str admin_username: A custom administrator account username (may only be set at creation time).
        :param str backup_schedule: The automated backup schedule (`HH:MM`).
        :param Sequence[str] ip_filters: A list of CIDR blocks to allow incoming connections from.
        :param str mysql_settings: MySQL configuration settings in JSON format (`exo dbaas type show mysql --settings=mysql` for reference).
        :param str version: MySQL major version (`exo dbaas type show mysql` for reference; may only be set at creation time).
        """
        DatabaseMysql._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            admin_password=admin_password,
            admin_username=admin_username,
            backup_schedule=backup_schedule,
            ip_filters=ip_filters,
            mysql_settings=mysql_settings,
            version=version,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             admin_password: Optional[str] = None,
             admin_username: Optional[str] = None,
             backup_schedule: Optional[str] = None,
             ip_filters: Optional[Sequence[str]] = None,
             mysql_settings: Optional[str] = None,
             version: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if admin_password is not None:
            _setter("admin_password", admin_password)
        if admin_username is not None:
            _setter("admin_username", admin_username)
        if backup_schedule is not None:
            _setter("backup_schedule", backup_schedule)
        if ip_filters is not None:
            _setter("ip_filters", ip_filters)
        if mysql_settings is not None:
            _setter("mysql_settings", mysql_settings)
        if version is not None:
            _setter("version", version)

    @property
    @pulumi.getter(name="adminPassword")
    def admin_password(self) -> Optional[str]:
        """
        A custom administrator account password (may only be set at creation time).
        """
        return pulumi.get(self, "admin_password")

    @property
    @pulumi.getter(name="adminUsername")
    def admin_username(self) -> Optional[str]:
        """
        A custom administrator account username (may only be set at creation time).
        """
        return pulumi.get(self, "admin_username")

    @property
    @pulumi.getter(name="backupSchedule")
    def backup_schedule(self) -> Optional[str]:
        """
        The automated backup schedule (`HH:MM`).
        """
        return pulumi.get(self, "backup_schedule")

    @property
    @pulumi.getter(name="ipFilters")
    def ip_filters(self) -> Optional[Sequence[str]]:
        """
        A list of CIDR blocks to allow incoming connections from.
        """
        return pulumi.get(self, "ip_filters")

    @property
    @pulumi.getter(name="mysqlSettings")
    def mysql_settings(self) -> Optional[str]:
        """
        MySQL configuration settings in JSON format (`exo dbaas type show mysql --settings=mysql` for reference).
        """
        return pulumi.get(self, "mysql_settings")

    @property
    @pulumi.getter
    def version(self) -> Optional[str]:
        """
        MySQL major version (`exo dbaas type show mysql` for reference; may only be set at creation time).
        """
        return pulumi.get(self, "version")


@pulumi.output_type
class DatabaseOpensearch(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "forkFromService":
            suggest = "fork_from_service"
        elif key == "indexPatterns":
            suggest = "index_patterns"
        elif key == "indexTemplate":
            suggest = "index_template"
        elif key == "ipFilters":
            suggest = "ip_filters"
        elif key == "keepIndexRefreshInterval":
            suggest = "keep_index_refresh_interval"
        elif key == "maxIndexCount":
            suggest = "max_index_count"
        elif key == "recoveryBackupName":
            suggest = "recovery_backup_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DatabaseOpensearch. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DatabaseOpensearch.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DatabaseOpensearch.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 dashboards: Optional['outputs.DatabaseOpensearchDashboards'] = None,
                 fork_from_service: Optional[str] = None,
                 index_patterns: Optional[Sequence['outputs.DatabaseOpensearchIndexPattern']] = None,
                 index_template: Optional['outputs.DatabaseOpensearchIndexTemplate'] = None,
                 ip_filters: Optional[Sequence[str]] = None,
                 keep_index_refresh_interval: Optional[bool] = None,
                 max_index_count: Optional[int] = None,
                 recovery_backup_name: Optional[str] = None,
                 settings: Optional[str] = None,
                 version: Optional[str] = None):
        """
        :param 'DatabaseOpensearchDashboardsArgs' dashboards: OpenSearch Dashboards settings
        :param str fork_from_service: ❗ Service name
        :param Sequence['DatabaseOpensearchIndexPatternArgs'] index_patterns: (can be used multiple times) Allows you to create glob style patterns and set a max number of indexes matching this pattern you want to keep. Creating indexes exceeding this value will cause the oldest one to get deleted. You could for example create a pattern looking like 'logs.?' and then create index logs.1, logs.2 etc, it will delete logs.1 once you create logs.6. Do note 'logs.?' does not apply to logs.10. Note: Setting max*index*count to 0 will do nothing and the pattern gets ignored.
        :param 'DatabaseOpensearchIndexTemplateArgs' index_template: Template settings for all new indexes
        :param Sequence[str] ip_filters: Allow incoming connections from this list of CIDR address block, e.g. `["10.20.0.0/16"]
        :param bool keep_index_refresh_interval: Aiven automation resets index.refresh_interval to default value for every index to be sure that indices are always visible to search. If it doesn't fit your case, you can disable this by setting up this flag to true.
        :param int max_index_count: Maximum number of indexes to keep (Minimum value is `0`)
        :param str recovery_backup_name: ❗ Name of a backup to recover from
        :param str settings: OpenSearch-specific settings, in json. e.g.`jsonencode({thread_pool_search_size: 64})`. Use `exo x get-dbaas-settings-opensearch` to get a list of available settings.
        :param str version: ❗ OpenSearch major version (`exo dbaas type show opensearch` for reference)
        """
        DatabaseOpensearch._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            dashboards=dashboards,
            fork_from_service=fork_from_service,
            index_patterns=index_patterns,
            index_template=index_template,
            ip_filters=ip_filters,
            keep_index_refresh_interval=keep_index_refresh_interval,
            max_index_count=max_index_count,
            recovery_backup_name=recovery_backup_name,
            settings=settings,
            version=version,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             dashboards: Optional['outputs.DatabaseOpensearchDashboards'] = None,
             fork_from_service: Optional[str] = None,
             index_patterns: Optional[Sequence['outputs.DatabaseOpensearchIndexPattern']] = None,
             index_template: Optional['outputs.DatabaseOpensearchIndexTemplate'] = None,
             ip_filters: Optional[Sequence[str]] = None,
             keep_index_refresh_interval: Optional[bool] = None,
             max_index_count: Optional[int] = None,
             recovery_backup_name: Optional[str] = None,
             settings: Optional[str] = None,
             version: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if dashboards is not None:
            _setter("dashboards", dashboards)
        if fork_from_service is not None:
            _setter("fork_from_service", fork_from_service)
        if index_patterns is not None:
            _setter("index_patterns", index_patterns)
        if index_template is not None:
            _setter("index_template", index_template)
        if ip_filters is not None:
            _setter("ip_filters", ip_filters)
        if keep_index_refresh_interval is not None:
            _setter("keep_index_refresh_interval", keep_index_refresh_interval)
        if max_index_count is not None:
            _setter("max_index_count", max_index_count)
        if recovery_backup_name is not None:
            _setter("recovery_backup_name", recovery_backup_name)
        if settings is not None:
            _setter("settings", settings)
        if version is not None:
            _setter("version", version)

    @property
    @pulumi.getter
    def dashboards(self) -> Optional['outputs.DatabaseOpensearchDashboards']:
        """
        OpenSearch Dashboards settings
        """
        return pulumi.get(self, "dashboards")

    @property
    @pulumi.getter(name="forkFromService")
    def fork_from_service(self) -> Optional[str]:
        """
        ❗ Service name
        """
        return pulumi.get(self, "fork_from_service")

    @property
    @pulumi.getter(name="indexPatterns")
    def index_patterns(self) -> Optional[Sequence['outputs.DatabaseOpensearchIndexPattern']]:
        """
        (can be used multiple times) Allows you to create glob style patterns and set a max number of indexes matching this pattern you want to keep. Creating indexes exceeding this value will cause the oldest one to get deleted. You could for example create a pattern looking like 'logs.?' and then create index logs.1, logs.2 etc, it will delete logs.1 once you create logs.6. Do note 'logs.?' does not apply to logs.10. Note: Setting max*index*count to 0 will do nothing and the pattern gets ignored.
        """
        return pulumi.get(self, "index_patterns")

    @property
    @pulumi.getter(name="indexTemplate")
    def index_template(self) -> Optional['outputs.DatabaseOpensearchIndexTemplate']:
        """
        Template settings for all new indexes
        """
        return pulumi.get(self, "index_template")

    @property
    @pulumi.getter(name="ipFilters")
    def ip_filters(self) -> Optional[Sequence[str]]:
        """
        Allow incoming connections from this list of CIDR address block, e.g. `["10.20.0.0/16"]
        """
        return pulumi.get(self, "ip_filters")

    @property
    @pulumi.getter(name="keepIndexRefreshInterval")
    def keep_index_refresh_interval(self) -> Optional[bool]:
        """
        Aiven automation resets index.refresh_interval to default value for every index to be sure that indices are always visible to search. If it doesn't fit your case, you can disable this by setting up this flag to true.
        """
        return pulumi.get(self, "keep_index_refresh_interval")

    @property
    @pulumi.getter(name="maxIndexCount")
    def max_index_count(self) -> Optional[int]:
        """
        Maximum number of indexes to keep (Minimum value is `0`)
        """
        return pulumi.get(self, "max_index_count")

    @property
    @pulumi.getter(name="recoveryBackupName")
    def recovery_backup_name(self) -> Optional[str]:
        """
        ❗ Name of a backup to recover from
        """
        return pulumi.get(self, "recovery_backup_name")

    @property
    @pulumi.getter
    def settings(self) -> Optional[str]:
        """
        OpenSearch-specific settings, in json. e.g.`jsonencode({thread_pool_search_size: 64})`. Use `exo x get-dbaas-settings-opensearch` to get a list of available settings.
        """
        return pulumi.get(self, "settings")

    @property
    @pulumi.getter
    def version(self) -> Optional[str]:
        """
        ❗ OpenSearch major version (`exo dbaas type show opensearch` for reference)
        """
        return pulumi.get(self, "version")


@pulumi.output_type
class DatabaseOpensearchDashboards(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "maxOldSpaceSize":
            suggest = "max_old_space_size"
        elif key == "requestTimeout":
            suggest = "request_timeout"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DatabaseOpensearchDashboards. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DatabaseOpensearchDashboards.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DatabaseOpensearchDashboards.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enabled: Optional[bool] = None,
                 max_old_space_size: Optional[int] = None,
                 request_timeout: Optional[int] = None):
        DatabaseOpensearchDashboards._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            enabled=enabled,
            max_old_space_size=max_old_space_size,
            request_timeout=request_timeout,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             enabled: Optional[bool] = None,
             max_old_space_size: Optional[int] = None,
             request_timeout: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if enabled is not None:
            _setter("enabled", enabled)
        if max_old_space_size is not None:
            _setter("max_old_space_size", max_old_space_size)
        if request_timeout is not None:
            _setter("request_timeout", request_timeout)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[bool]:
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter(name="maxOldSpaceSize")
    def max_old_space_size(self) -> Optional[int]:
        return pulumi.get(self, "max_old_space_size")

    @property
    @pulumi.getter(name="requestTimeout")
    def request_timeout(self) -> Optional[int]:
        return pulumi.get(self, "request_timeout")


@pulumi.output_type
class DatabaseOpensearchIndexPattern(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "maxIndexCount":
            suggest = "max_index_count"
        elif key == "sortingAlgorithm":
            suggest = "sorting_algorithm"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DatabaseOpensearchIndexPattern. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DatabaseOpensearchIndexPattern.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DatabaseOpensearchIndexPattern.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 max_index_count: Optional[int] = None,
                 pattern: Optional[str] = None,
                 sorting_algorithm: Optional[str] = None):
        DatabaseOpensearchIndexPattern._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            max_index_count=max_index_count,
            pattern=pattern,
            sorting_algorithm=sorting_algorithm,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             max_index_count: Optional[int] = None,
             pattern: Optional[str] = None,
             sorting_algorithm: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if max_index_count is not None:
            _setter("max_index_count", max_index_count)
        if pattern is not None:
            _setter("pattern", pattern)
        if sorting_algorithm is not None:
            _setter("sorting_algorithm", sorting_algorithm)

    @property
    @pulumi.getter(name="maxIndexCount")
    def max_index_count(self) -> Optional[int]:
        return pulumi.get(self, "max_index_count")

    @property
    @pulumi.getter
    def pattern(self) -> Optional[str]:
        return pulumi.get(self, "pattern")

    @property
    @pulumi.getter(name="sortingAlgorithm")
    def sorting_algorithm(self) -> Optional[str]:
        return pulumi.get(self, "sorting_algorithm")


@pulumi.output_type
class DatabaseOpensearchIndexTemplate(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "mappingNestedObjectsLimit":
            suggest = "mapping_nested_objects_limit"
        elif key == "numberOfReplicas":
            suggest = "number_of_replicas"
        elif key == "numberOfShards":
            suggest = "number_of_shards"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DatabaseOpensearchIndexTemplate. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DatabaseOpensearchIndexTemplate.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DatabaseOpensearchIndexTemplate.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 mapping_nested_objects_limit: Optional[int] = None,
                 number_of_replicas: Optional[int] = None,
                 number_of_shards: Optional[int] = None):
        DatabaseOpensearchIndexTemplate._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            mapping_nested_objects_limit=mapping_nested_objects_limit,
            number_of_replicas=number_of_replicas,
            number_of_shards=number_of_shards,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             mapping_nested_objects_limit: Optional[int] = None,
             number_of_replicas: Optional[int] = None,
             number_of_shards: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if mapping_nested_objects_limit is not None:
            _setter("mapping_nested_objects_limit", mapping_nested_objects_limit)
        if number_of_replicas is not None:
            _setter("number_of_replicas", number_of_replicas)
        if number_of_shards is not None:
            _setter("number_of_shards", number_of_shards)

    @property
    @pulumi.getter(name="mappingNestedObjectsLimit")
    def mapping_nested_objects_limit(self) -> Optional[int]:
        return pulumi.get(self, "mapping_nested_objects_limit")

    @property
    @pulumi.getter(name="numberOfReplicas")
    def number_of_replicas(self) -> Optional[int]:
        return pulumi.get(self, "number_of_replicas")

    @property
    @pulumi.getter(name="numberOfShards")
    def number_of_shards(self) -> Optional[int]:
        return pulumi.get(self, "number_of_shards")


@pulumi.output_type
class DatabasePg(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "adminPassword":
            suggest = "admin_password"
        elif key == "adminUsername":
            suggest = "admin_username"
        elif key == "backupSchedule":
            suggest = "backup_schedule"
        elif key == "ipFilters":
            suggest = "ip_filters"
        elif key == "pgSettings":
            suggest = "pg_settings"
        elif key == "pgbouncerSettings":
            suggest = "pgbouncer_settings"
        elif key == "pglookoutSettings":
            suggest = "pglookout_settings"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DatabasePg. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DatabasePg.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DatabasePg.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 admin_password: Optional[str] = None,
                 admin_username: Optional[str] = None,
                 backup_schedule: Optional[str] = None,
                 ip_filters: Optional[Sequence[str]] = None,
                 pg_settings: Optional[str] = None,
                 pgbouncer_settings: Optional[str] = None,
                 pglookout_settings: Optional[str] = None,
                 version: Optional[str] = None):
        """
        :param str admin_password: A custom administrator account password (may only be set at creation time).
        :param str admin_username: A custom administrator account username (may only be set at creation time).
        :param str backup_schedule: The automated backup schedule (`HH:MM`).
        :param Sequence[str] ip_filters: A list of CIDR blocks to allow incoming connections from.
        :param str pg_settings: PostgreSQL configuration settings in JSON format (`exo dbaas type show pg --settings=pg` for reference).
        :param str pgbouncer_settings: PgBouncer configuration settings in JSON format (`exo dbaas type show pg --settings=pgbouncer` for reference).
        :param str pglookout_settings: pglookout configuration settings in JSON format (`exo dbaas type show pg --settings=pglookout` for reference).
        :param str version: PostgreSQL major version (`exo dbaas type show pg` for reference; may only be set at creation time).
        """
        DatabasePg._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            admin_password=admin_password,
            admin_username=admin_username,
            backup_schedule=backup_schedule,
            ip_filters=ip_filters,
            pg_settings=pg_settings,
            pgbouncer_settings=pgbouncer_settings,
            pglookout_settings=pglookout_settings,
            version=version,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             admin_password: Optional[str] = None,
             admin_username: Optional[str] = None,
             backup_schedule: Optional[str] = None,
             ip_filters: Optional[Sequence[str]] = None,
             pg_settings: Optional[str] = None,
             pgbouncer_settings: Optional[str] = None,
             pglookout_settings: Optional[str] = None,
             version: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if admin_password is not None:
            _setter("admin_password", admin_password)
        if admin_username is not None:
            _setter("admin_username", admin_username)
        if backup_schedule is not None:
            _setter("backup_schedule", backup_schedule)
        if ip_filters is not None:
            _setter("ip_filters", ip_filters)
        if pg_settings is not None:
            _setter("pg_settings", pg_settings)
        if pgbouncer_settings is not None:
            _setter("pgbouncer_settings", pgbouncer_settings)
        if pglookout_settings is not None:
            _setter("pglookout_settings", pglookout_settings)
        if version is not None:
            _setter("version", version)

    @property
    @pulumi.getter(name="adminPassword")
    def admin_password(self) -> Optional[str]:
        """
        A custom administrator account password (may only be set at creation time).
        """
        return pulumi.get(self, "admin_password")

    @property
    @pulumi.getter(name="adminUsername")
    def admin_username(self) -> Optional[str]:
        """
        A custom administrator account username (may only be set at creation time).
        """
        return pulumi.get(self, "admin_username")

    @property
    @pulumi.getter(name="backupSchedule")
    def backup_schedule(self) -> Optional[str]:
        """
        The automated backup schedule (`HH:MM`).
        """
        return pulumi.get(self, "backup_schedule")

    @property
    @pulumi.getter(name="ipFilters")
    def ip_filters(self) -> Optional[Sequence[str]]:
        """
        A list of CIDR blocks to allow incoming connections from.
        """
        return pulumi.get(self, "ip_filters")

    @property
    @pulumi.getter(name="pgSettings")
    def pg_settings(self) -> Optional[str]:
        """
        PostgreSQL configuration settings in JSON format (`exo dbaas type show pg --settings=pg` for reference).
        """
        return pulumi.get(self, "pg_settings")

    @property
    @pulumi.getter(name="pgbouncerSettings")
    def pgbouncer_settings(self) -> Optional[str]:
        """
        PgBouncer configuration settings in JSON format (`exo dbaas type show pg --settings=pgbouncer` for reference).
        """
        return pulumi.get(self, "pgbouncer_settings")

    @property
    @pulumi.getter(name="pglookoutSettings")
    def pglookout_settings(self) -> Optional[str]:
        """
        pglookout configuration settings in JSON format (`exo dbaas type show pg --settings=pglookout` for reference).
        """
        return pulumi.get(self, "pglookout_settings")

    @property
    @pulumi.getter
    def version(self) -> Optional[str]:
        """
        PostgreSQL major version (`exo dbaas type show pg` for reference; may only be set at creation time).
        """
        return pulumi.get(self, "version")


@pulumi.output_type
class DatabaseRedis(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "ipFilters":
            suggest = "ip_filters"
        elif key == "redisSettings":
            suggest = "redis_settings"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DatabaseRedis. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DatabaseRedis.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DatabaseRedis.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 ip_filters: Optional[Sequence[str]] = None,
                 redis_settings: Optional[str] = None):
        """
        :param Sequence[str] ip_filters: A list of CIDR blocks to allow incoming connections from.
        :param str redis_settings: Redis configuration settings in JSON format (`exo dbaas type show redis --settings=redis` for reference).
        """
        DatabaseRedis._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            ip_filters=ip_filters,
            redis_settings=redis_settings,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             ip_filters: Optional[Sequence[str]] = None,
             redis_settings: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if ip_filters is not None:
            _setter("ip_filters", ip_filters)
        if redis_settings is not None:
            _setter("redis_settings", redis_settings)

    @property
    @pulumi.getter(name="ipFilters")
    def ip_filters(self) -> Optional[Sequence[str]]:
        """
        A list of CIDR blocks to allow incoming connections from.
        """
        return pulumi.get(self, "ip_filters")

    @property
    @pulumi.getter(name="redisSettings")
    def redis_settings(self) -> Optional[str]:
        """
        Redis configuration settings in JSON format (`exo dbaas type show redis --settings=redis` for reference).
        """
        return pulumi.get(self, "redis_settings")


@pulumi.output_type
class DatabaseTimeouts(dict):
    def __init__(__self__, *,
                 create: Optional[str] = None,
                 delete: Optional[str] = None,
                 read: Optional[str] = None,
                 update: Optional[str] = None):
        """
        :param str create: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        :param str delete: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Setting a timeout for a Delete operation is only applicable if changes are saved into state before the destroy operation occurs.
        :param str read: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Read operations occur during any refresh or planning operation when refresh is enabled.
        :param str update: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        DatabaseTimeouts._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            create=create,
            delete=delete,
            read=read,
            update=update,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             create: Optional[str] = None,
             delete: Optional[str] = None,
             read: Optional[str] = None,
             update: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if create is not None:
            _setter("create", create)
        if delete is not None:
            _setter("delete", delete)
        if read is not None:
            _setter("read", read)
        if update is not None:
            _setter("update", update)

    @property
    @pulumi.getter
    def create(self) -> Optional[str]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        return pulumi.get(self, "create")

    @property
    @pulumi.getter
    def delete(self) -> Optional[str]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Setting a timeout for a Delete operation is only applicable if changes are saved into state before the destroy operation occurs.
        """
        return pulumi.get(self, "delete")

    @property
    @pulumi.getter
    def read(self) -> Optional[str]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Read operations occur during any refresh or planning operation when refresh is enabled.
        """
        return pulumi.get(self, "read")

    @property
    @pulumi.getter
    def update(self) -> Optional[str]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        return pulumi.get(self, "update")


@pulumi.output_type
class GetDatabaseURITimeoutsResult(dict):
    def __init__(__self__, *,
                 read: Optional[str] = None):
        """
        :param str read: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Read operations occur during any refresh or planning operation when refresh is enabled.
        """
        GetDatabaseURITimeoutsResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            read=read,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             read: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if read is not None:
            _setter("read", read)

    @property
    @pulumi.getter
    def read(self) -> Optional[str]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Read operations occur during any refresh or planning operation when refresh is enabled.
        """
        return pulumi.get(self, "read")


@pulumi.output_type
class GetNLBServiceListServiceResult(dict):
    def __init__(__self__, *,
                 description: str,
                 healthcheck: 'outputs.GetNLBServiceListServiceHealthcheckResult',
                 id: str,
                 instance_pool_id: str,
                 name: str,
                 port: int,
                 protocol: str,
                 state: str,
                 strategy: str,
                 target_port: int):
        """
        :param str description: NLB service description.
        :param str id: NLB service ID.
        :param str instance_pool_id: The exoscale*instance*pool (ID) to forward traffic to.
        :param str name: NLB Service name.
        :param int port: Port exposed on the NLB's public IP.
        :param str protocol: Network traffic protocol.
        :param str state: NLB Service State.
        :param str strategy: The strategy (`round-robin`|`source-hash`).
        :param int target_port: Port on which the network traffic will be forwarded to on the receiving instance.
        """
        GetNLBServiceListServiceResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            description=description,
            healthcheck=healthcheck,
            id=id,
            instance_pool_id=instance_pool_id,
            name=name,
            port=port,
            protocol=protocol,
            state=state,
            strategy=strategy,
            target_port=target_port,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             description: str,
             healthcheck: 'outputs.GetNLBServiceListServiceHealthcheckResult',
             id: str,
             instance_pool_id: str,
             name: str,
             port: int,
             protocol: str,
             state: str,
             strategy: str,
             target_port: int,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("description", description)
        _setter("healthcheck", healthcheck)
        _setter("id", id)
        _setter("instance_pool_id", instance_pool_id)
        _setter("name", name)
        _setter("port", port)
        _setter("protocol", protocol)
        _setter("state", state)
        _setter("strategy", strategy)
        _setter("target_port", target_port)

    @property
    @pulumi.getter
    def description(self) -> str:
        """
        NLB service description.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter
    def healthcheck(self) -> 'outputs.GetNLBServiceListServiceHealthcheckResult':
        return pulumi.get(self, "healthcheck")

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        NLB service ID.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="instancePoolId")
    def instance_pool_id(self) -> str:
        """
        The exoscale*instance*pool (ID) to forward traffic to.
        """
        return pulumi.get(self, "instance_pool_id")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        NLB Service name.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def port(self) -> int:
        """
        Port exposed on the NLB's public IP.
        """
        return pulumi.get(self, "port")

    @property
    @pulumi.getter
    def protocol(self) -> str:
        """
        Network traffic protocol.
        """
        return pulumi.get(self, "protocol")

    @property
    @pulumi.getter
    def state(self) -> str:
        """
        NLB Service State.
        """
        return pulumi.get(self, "state")

    @property
    @pulumi.getter
    def strategy(self) -> str:
        """
        The strategy (`round-robin`|`source-hash`).
        """
        return pulumi.get(self, "strategy")

    @property
    @pulumi.getter(name="targetPort")
    def target_port(self) -> int:
        """
        Port on which the network traffic will be forwarded to on the receiving instance.
        """
        return pulumi.get(self, "target_port")


@pulumi.output_type
class GetNLBServiceListServiceHealthcheckResult(dict):
    def __init__(__self__, *,
                 interval: int,
                 mode: str,
                 port: int,
                 retries: int,
                 timeout: int,
                 tls_sni: str,
                 uri: str):
        GetNLBServiceListServiceHealthcheckResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            interval=interval,
            mode=mode,
            port=port,
            retries=retries,
            timeout=timeout,
            tls_sni=tls_sni,
            uri=uri,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             interval: int,
             mode: str,
             port: int,
             retries: int,
             timeout: int,
             tls_sni: str,
             uri: str,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("interval", interval)
        _setter("mode", mode)
        _setter("port", port)
        _setter("retries", retries)
        _setter("timeout", timeout)
        _setter("tls_sni", tls_sni)
        _setter("uri", uri)

    @property
    @pulumi.getter
    def interval(self) -> int:
        return pulumi.get(self, "interval")

    @property
    @pulumi.getter
    def mode(self) -> str:
        return pulumi.get(self, "mode")

    @property
    @pulumi.getter
    def port(self) -> int:
        return pulumi.get(self, "port")

    @property
    @pulumi.getter
    def retries(self) -> int:
        return pulumi.get(self, "retries")

    @property
    @pulumi.getter
    def timeout(self) -> int:
        return pulumi.get(self, "timeout")

    @property
    @pulumi.getter(name="tlsSni")
    def tls_sni(self) -> str:
        return pulumi.get(self, "tls_sni")

    @property
    @pulumi.getter
    def uri(self) -> str:
        return pulumi.get(self, "uri")


@pulumi.output_type
class GetNLBServiceListTimeoutsResult(dict):
    def __init__(__self__, *,
                 read: Optional[str] = None):
        """
        :param str read: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Read operations occur during any refresh or planning operation when refresh is enabled.
        """
        GetNLBServiceListTimeoutsResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            read=read,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             read: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if read is not None:
            _setter("read", read)

    @property
    @pulumi.getter
    def read(self) -> Optional[str]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Read operations occur during any refresh or planning operation when refresh is enabled.
        """
        return pulumi.get(self, "read")


